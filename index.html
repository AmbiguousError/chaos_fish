<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goldfish Pond Population Dynamics</title>
    <!-- Embedded CSS for styling the page -->
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #e0f2f7;
            color: #333;
            margin: 20px;
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            max-width: 1000px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #007bff;
            margin-bottom: 15px;
            font-size: 2.2em;
        }

        p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .control-group {
            text-align: left;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        .control-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
        }

        .control-group span {
            font-weight: bold;
            color: #007bff;
            margin-left: 10px;
        }

        .control-group .description {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
            margin-bottom: 0;
        }

        button {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin: 0 10px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover:not(:disabled) {
            background-color: #218838;
            transform: translateY(-2px);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button#stopButton {
            background-color: #dc3545;
        }

        button#stopButton:hover:not(:disabled) {
            background-color: #c82333;
        }

        button#resetButton {
            background-color: #ffc107;
            color: #333;
        }

        button#resetButton:hover:not(:disabled) {
            background-color: #e0a800;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* New button styles for LLM features */
        button#getInsightButton, button#generateBifurcationButton { /* Added bifurcation button */
            background-color: #6f42c1; /* Purple color */
            color: white;
        }
        button#getInsightButton:hover:not(:disabled), button#generateBifurcationButton:hover:not(:disabled) {
            background-color: #563391;
        }


        .simulation-area {
            display: flex;
            flex-wrap: wrap; /* Allows wrapping on smaller screens */
            gap: 30px;
            justify-content: center;
            margin-top: 30px;
            margin-bottom: 30px; /* Added space before LLM output */
        }

        .chart-container {
            flex: 2; /* Takes more space */
            min-width: 400px; /* Minimum width for the chart */
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }

        .current-values {
            flex: 1; /* Takes remaining space */
            min-width: 250px; /* Minimum width for values */
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            text-align: left;
        }

        h2 {
            color: #0056b3;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: #fff;
            display: block;
            margin: 0 auto;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
        }

        .current-values p {
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #444;
        }

        .current-values strong {
            color: #007bff;
        }

        .current-values .note {
            font-size: 0.9em;
            color: #777;
            margin-top: 20px;
        }

        /* Styles for the custom message box */
        #messageBox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            text-align: center;
            max-width: 400px;
            width: 90%;
            animation: fadeIn 0.3s ease-out;
            display: none; /* Hidden by default */
        }

        #messageBoxOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            animation: fadeIn 0.3s ease-out;
            display: none; /* Hidden by default */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%); }
            to { opacity: 0; transform: translate(-50%, -60%); }
        }

        /* New styles for the pond animation area */
        .pond-container {
            flex: 2; /* Takes more space, similar to chart */
            min-width: 400px;
            background-color: #d0f0f8; /* Light blue for water */
            border: 5px solid #007bff; /* Pond border */
            border-radius: 50%; /* Make it circular/oval */
            overflow: hidden; /* Keep fish inside */
            position: relative;
            aspect-ratio: 16 / 9; /* Maintain aspect ratio for pond */
            margin-bottom: 30px; /* Space below pond */
            box-shadow: inset 0 0 15px rgba(0, 123, 255, 0.5), 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        #pondCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Pond background is from .pond-container */
        }

        /* Styles for LLM Output Area */
        #llmOutputArea {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #c3b1e6; /* Consistent border with LLM elements */
            border-radius: 8px;
            background-color: #e6e6fa; /* Light purple background */
            text-align: left;
            display: none; /* Hidden by default */
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            word-wrap: break-word; /* Ensure long words wraps */
        }
        #llmOutputArea h3 {
            color: #563391;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5em;
            text-align: center;
        }
        #llmOutputText {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 0;
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #6f42c1; /* Purple */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* New styles for the return map chart */
        .return-map-container, .bifurcation-map-container { /* Added bifurcation container */
            width: 100%; /* Take full width below simulation area */
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            margin-top: 20px; /* Space above */
            margin-left: auto;
            margin-right: auto;
            max-width: 800px; /* Match other content max-width */
        }
        #returnMapCanvas, #bifurcationMapCanvas { /* Added bifurcation canvas */
            border: 1px solid #ccc;
            background-color: #fff;
            display: block;
            margin: 0 auto;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
        }


        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr; /* Stack controls on small screens */
            }
            .simulation-area {
                flex-direction: column; /* Stack chart and values */
            }
            .chart-container, .current-values, .pond-container, .return-map-container, .bifurcation-map-container { /* Include pond and return map in stacking */
                min-width: unset; /* Remove min-width to allow full flexibility */
                width: 100%;
                border-radius: 8px; /* Square off pond on mobile for better fit */
                aspect-ratio: unset; /* Let height adjust for mobile */
                height: 300px; /* Fixed height for pond on mobile */
            }
            button {
                margin: 10px 5px; /* Adjust button spacing */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Goldfish Pond Population Dynamics</h1>
        <p>This simulation visually demonstrates the **Butterfly Effect** as it applies to a goldfish pond population, illustrating the core principles of **chaos theory** and the influence of **randomness**. While our underlying population growth rule is simple and deterministic (the logistic map), you'll observe how tiny, almost imperceptible differences in starting conditions for the goldfish population, coupled with random external disturbances, can lead to wildly divergent and unpredictable long-term outcomes. This highlights that even for seemingly simple systems, precise long-term prediction can be impossible, revealing patterns of structured unpredictability. Adjust the parameters to actively explore how the pond's population shifts between stable, oscillating, and truly chaotic states.</p>

        <div class="controls">
            <!-- Control group for Growth Rate (r) -->
            <div class="control-group">
                <label for="growthRate">Growth Rate (r):</label>
                <input type="range" id="growthRate" min="0.1" max="4.0" step="0.01" value="3.5">
                <span id="growthRateValue">3.5</span>
                <p class="description">Higher values of 'r' (especially above ~3.57) push the system towards chaotic behavior, where small changes have unpredictable long-term effects. (Range: 0.1 - 4.0)</p>
            </div>
            <!-- Control group for Initial Population (x0) -->
            <div class="control-group">
                <label for="initialPopulation">Initial Population (x0):</label>
                <input type="range" id="initialPopulation" min="0.01" max="0.99" step="0.01" value="0.5">
                <span id="initialPopulationValue">0.5</span>
                <p class="description">The starting normalized population (0 to 1). In chaotic regimes, even tiny differences here can lead to vastly different outcomes over time. (Range: 0.01 - 0.99)</p>
            </div>
            <!-- Control group for Randomness Factor -->
            <div class="control-group">
                <label for="randomnessFactor">Randomness Factor:</label>
                <input type="range" id="randomnessFactor" min="0.0" max="0.1" step="0.001" value="0.01">
                <span id="randomnessFactorValue">0.01</span>
                <p class="description">The maximum magnitude of random environmental perturbations (e.g., unexpected deaths or births) applied at each step. (Range: 0.0 - 0.1)</p>
            </div>
            <!-- Control group for Randomness Frequency -->
            <div class="control-group">
                <label for="randomnessFrequency">Randomness Frequency:</label>
                <input type="range" id="randomnessFrequency" min="0.0" max="1.0" step="0.01" value="0.1">
                <span id="randomnessFrequencyValue">0.1</span>
                <p class="description">The probability (0 to 1) that a random event occurs during each simulation step. (Range: 0.0 - 1.0)</p>
            </div>

            <!-- New control group for Moving Average -->
            <div class="control-group">
                <label for="movingAverageEnabled">
                    <input type="checkbox" id="movingAverageEnabled"> Show Moving Average
                </label>
                <label for="movingAverageWindow" style="margin-top: 10px;">Window Length:</label>
                <input type="range" id="movingAverageWindow" min="2" max="50" step="1" value="10">
                <span id="movingAverageWindowValue">10</span>
                <p class="description">Number of data points for the moving average calculation.</p>
            </div>


            <!-- Action buttons for the simulation -->
            <button id="startButton">Start Simulation</button>
            <button id="stopButton" disabled>Stop Simulation</button>
            <button id="resetButton">Reset Simulation</button>
            <button id="getInsightButton">Get Population Insight ✨</button>
            <button id="generateBifurcationButton">Generate Bifurcation Diagram 📈</button>
        </div>

        <!-- New section for the Bifurcation Diagram Chart (Moved to be immediately below buttons) -->
        <div class="bifurcation-map-container">
            <h2>Bifurcation Diagram (Attractors vs. Growth Rate 'r')</h2>
            <p class="description">This diagram is like a roadmap for the goldfish population's long-term future, revealing its behavior as you change the "growth rate" (the 'r' value). It plots the population's eventual settled values (attractors) for each 'r'. You'll see it transition from a single stable line, to splitting lines (oscillations), and then to dense, filled regions as chaos emerges. It's a visual journey showing how the system shifts from predictable to unpredictable patterns.</p>
            <canvas id="bifurcationMapCanvas" width="800" height="400"></canvas>
        </div>

        <div class="simulation-area">
            <!-- Canvas for the population chart -->
            <div class="chart-container">
                <h2>Population Over Time (Normalized)</h2>
                <canvas id="populationChart" width="800" height="400"></canvas>
            </div>

            <!-- Pond Animation Area -->
            <div class="pond-container">
                <h2>Pond Animation</h2>
                <canvas id="pondCanvas"></canvas>
            </div>

            <!-- Display current simulation values -->
            <div class="current-values">
                <h2>Current State</h2>
                <p><strong>Generation:</strong> <span id="currentGeneration">0</span></p>
                <p><strong>Current Population (x):</strong> <span id="currentPopulationX">0.5000</span></p>
                <p><strong>Applied Growth Rate (r):</strong> <span id="currentGrowthRate">3.50</span></p>
                <p><strong>Random Event Applied:</strong> <span id="randomEventApplied">No</span></p>
                <p class="note">Note: Population is normalized from 0 (extinction) to 1 (carrying capacity of the pond). This simplified model represents a fraction of the maximum possible population.</p>
            </div>
        </div>

        <!-- New section for the Return Map Chart -->
        <div class="return-map-container">
            <h2>Phase Space Plot (Return Map: $x_n$ vs $x_{n+1}$)</h2>
            <p class="description">This chart plots the current population ($x_n$) against the population in the next step ($x_{n+1}$). It reveals the underlying deterministic rule of the logistic map, showing how points always fall on the parabola, even when the time series is chaotic. Randomness is visualized as points deviating from this perfect curve.</p>
            <canvas id="returnMapCanvas" width="800" height="400"></canvas>
        </div>

        <!-- Area to display LLM output - MOVED HERE and simplified for single output -->
        <div id="llmOutputArea">
            <h3>AI-Generated Insight:</h3>
            <p id="llmOutputText">Click the "Get Population Insight ✨" button to get an AI-powered analysis of your goldfish pond!</p>
        </div>
    </div>

    <!-- Embedded JavaScript for simulation logic and interactions -->
    <script>
        // === 1. DOM Element References ===
        // Get references to all necessary HTML elements by their IDs.
        // Caching these references improves performance by avoiding repeated DOM lookups.
        let growthRateSlider;
        let growthRateValueSpan;
        let initialPopulationSlider;
        let initialPopulationValueSpan;
        let randomnessFactorSlider;
        let randomnessFactorValueSpan;
        let randomnessFrequencySlider;
        let randomnessFrequencyValueSpan;

        let startButton;
        let stopButton;
        let resetButton;

        let getInsightButton;
        let generateBifurcationButton;
        let llmOutputArea;
        let llmOutputTitle;
        let llmOutputText;

        // References for Moving Average controls
        let movingAverageEnabledCheckbox;
        let movingAverageWindowSlider;
        let movingAverageWindowValueSpan;

        let currentGenerationSpan;
        let currentPopulationXSpan;
        let currentGrowthRateSpan;
        let randomEventAppliedSpan;

        // References for Canvas elements and their 2D rendering contexts
        let populationChartCanvas;
        let populationChartCtx;

        let pondCanvas;
        let pondCtx;

        let returnMapCanvas;
        let returnMapCtx;

        let bifurcationMapCanvas;
        let bifurcationMapCtx;


        // === 2. Simulation Variables ===
        let r; // Growth rate for the logistic map (controls population dynamics).
        let x; // Current normalized population (0 = extinction, 1 = carrying capacity).
        let randomnessFactor; // Maximum magnitude of random perturbations applied.
        let randomnessFrequency; // Probability (0-1) of a random event occurring each step.
        let generation = 0; // Current simulation step/generation count.
        let simulationInterval = null; // Stores the ID returned by setInterval for stopping the main simulation loop.
        let pondAnimationFrameId = null; // Stores the ID returned by requestAnimationFrame for the pond animation.

        const populationHistory = []; // Array to store historical 'x' values for the time series chart.
        const maxDataPoints = 200; // Max number of data points to display on the time series chart.

        // Moving Average settings
        let movingAverageEnabled = false; // Flag to enable/disable the moving average line.
        let movingAverageWindow = 10; // Number of previous data points to average for the moving average line.

        // Pond Animation settings
        const maxPondFish = 150; // Visual maximum number of fish displayed in the pond animation.
        let pondFish = []; // Array of objects representing individual fish in the pond animation.


        // === 3. Core Simulation Functions ===

        /**
         * Initializes or resets the simulation parameters and UI.
         */
        function initializeSimulation() {
            console.log("initializeSimulation called: Setting up initial parameters.");

            // Parse initial values from UI sliders
            r = parseFloat(growthRateSlider.value);
            x = parseFloat(initialPopulationSlider.value);
            randomnessFactor = parseFloat(randomnessFactorSlider.value);
            randomnessFrequency = parseFloat(randomnessFrequencySlider.value);

            // Get initial state of moving average controls
            movingAverageEnabled = movingAverageEnabledCheckbox.checked;
            movingAverageWindow = parseInt(movingAverageWindowSlider.value);

            // Reset simulation state
            generation = 0;
            populationHistory.length = 0; // Clear previous population data
            populationHistory.push(x); // Add initial population to history

            // Initialize visual components
            initializePond(); // Setup fish in the pond
            updateDisplay(); // Update current state numerical display
            drawChart(); // Draw the initial population chart
            drawReturnMap(); // Draw the initial return map axes and parabola
            drawBifurcationMapInitialState(); // Draw initial state for bifurcation diagram

            console.log(`Initial state set: r=${r.toFixed(2)}, x=${x.toFixed(4)}, ` +
                        `randomnessFactor=${randomnessFactor.toFixed(3)}, randomnessFrequency=${randomnessFrequency.toFixed(2)}`);

            // Dynamically size canvases based on their container's current size (for responsiveness)
            // And ensure pond animation loop is running
            if (pondCanvas) {
                const container = pondCanvas.parentElement;
                pondCanvas.width = container.clientWidth;
                pondCanvas.height = container.clientHeight;
                if (pondAnimationFrameId) {
                    cancelAnimationFrame(pondAnimationFrameId); // Stop any existing animation frame
                }
                animatePond(); // Start the pond animation loop
            }
            if (returnMapCanvas) {
                const container = returnMapCanvas.parentElement;
                returnMapCanvas.width = container.clientWidth;
                returnMapCanvas.height = container.clientHeight;
            }
            if (bifurcationMapCanvas) {
                const container = bifurcationMapCanvas.parentElement;
                bifurcationMapCanvas.width = container.clientWidth;
                bifurcationMapCanvas.height = container.clientHeight;
            }

            // Reset LLM output area on initialization
            llmOutputArea.style.display = 'block';
            llmOutputTitle.textContent = "AI-Generated Insight:";
            llmOutputText.innerHTML = "Click the \"Get Population Insight ✨\" button to get an AI-powered analysis of your goldfish pond!";
        }

        /**
         * Runs a single step of the population simulation.
         * Calculates the next population value based on the logistic map and applies randomness.
         * Updates UI elements and charts.
         */
        function runSimulationStep() {
            try {
                generation++;
                // Store current X before calculating next X for return map. This ensures x_current and x_next
                // in drawReturnMap correspond to a single (x_n, x_{n+1}) pair before 'x' is updated.
                const currentXForReturnMap = x;

                // 1. Logistic Map Calculation (Deterministic Chaos)
                // The core equation: x_next = r * x_current * (1 - x_current)
                let nextX = r * x * (1 - x);

                // Clamp nextX to stay within biological bounds [0, 1].
                // This prevents the population from going negative or exceeding the carrying capacity.
                nextX = Math.max(0, Math.min(1, nextX));

                // 2. Introduce Randomness (Stochastic Perturbation)
                let appliedRandomEvent = false;
                // Check if a random event should occur based on the randomnessFrequency probability.
                if (Math.random() < randomnessFrequency) {
                    // Generate a random perturbation (positive or negative) within the defined randomnessFactor.
                    const perturbation = (Math.random() * 2 - 1) * randomnessFactor;
                    nextX += perturbation; // Apply the perturbation to the calculated next population.
                    appliedRandomEvent = true;
                }

                // Clamp nextX again after potential random perturbation to ensure it stays within [0, 1].
                nextX = Math.max(0, Math.min(1, nextX));

                x = nextX; // Update the global current population variable to the newly calculated value.

                // Store the current population in history for the time series chart.
                populationHistory.push(x);
                // If history exceeds maxDataPoints, remove the oldest data point to maintain fixed window.
                if (populationHistory.length > maxDataPoints) {
                    populationHistory.shift();
                }

                // Update all UI components.
                updateDisplay(appliedRandomEvent); // Update current state numerical display.
                drawChart(); // Redraw the population time series chart (includes moving average if enabled).
                drawReturnMap(currentXForReturnMap, x); // Draw the new point on the return map.

                // Check for extinction condition.
                // If population falls below a small threshold, stop the simulation.
                if (x <= 0.001) {
                    stopSimulation();
                    displayMessage("Population Extinct!", `The goldfish population reached a negligible level (${x.toFixed(4)}) and the simulation has stopped.`);
                    console.log(`Simulation stopped: Population effectively extinct at ${x.toFixed(4)}.`);
                }
            } catch (error) {
                console.error("Error in runSimulationStep:", error);
                stopSimulation(); // Stop simulation on error to prevent continuous errors.
                displayMessage("Simulation Error!", `An error occurred during simulation: ${error.message}. Check console for details.`);
            }
        }

        /**
         * Starts the main simulation loop.
         * The Bifurcation Diagram generation is now explicitly triggered by its own button.
         */
        async function startSimulation() {
            console.log("startSimulation function invoked (triggered by button click).");
            console.log(`Current simulationInterval ID on start click: ${simulationInterval}`);

            if (simulationInterval !== null) {
                console.log("Simulation already running. Ignoring start request to prevent multiple intervals.");
                return;
            }

            // Disable Start button and enable Stop button immediately.
            startButton.disabled = true;
            stopButton.disabled = false;
            getInsightButton.disabled = false; // LLM button remains active
            generateBifurcationButton.disabled = false; // Bifurcation button remains active

            console.log("Buttons state: Start disabled, Stop enabled, AI & Bifurcation enabled.");

            // Set up the recurring interval for running simulation steps.
            try {
                simulationInterval = setInterval(runSimulationStep, 100); // Calls runSimulationStep every 100ms.
                console.log(`Main simulation interval successfully started. New interval ID: ${simulationInterval}`);
            } catch (error) {
                console.error("Error setting up main simulation interval:", error);
                displayMessage("Start Error!", `Could not start main simulation: ${error.message}.`);
                // Restore button states if an error occurs during interval setup.
                startButton.disabled = false;
                stopButton.disabled = true;
                getInsightButton.disabled = false;
                generateBifurcationButton.disabled = false;
                console.log("Buttons state after interval setup error: Start enabled, Stop disabled, AI & Bifurcation enabled.");
            }
        }

        /**
         * Stops the currently running simulation loop and associated animations.
         */
        function stopSimulation() {
            console.log(`stopSimulation function invoked. simulationInterval before clearing: ${simulationInterval}`);

            // Clear the main simulation interval if it's active.
            if (simulationInterval !== null) {
                clearInterval(simulationInterval);
                simulationInterval = null; // Reset the interval ID.
                console.log(`Simulation interval cleared. simulationInterval is now: ${simulationInterval}`);
            } else {
                console.log("No simulation interval was active to clear.");
            }

            // Update button states after stopping the simulation.
            startButton.disabled = false; // Enable start button.
            stopButton.disabled = true; // Disable stop button.
            getInsightButton.disabled = false; // Ensure AI Insight button is enabled.
            generateBifurcationButton.disabled = false; // Ensure Bifurcation button is enabled.
            console.log("Buttons state: Start enabled, Stop disabled, AI & Bifurcation enabled.");

            // Stop the pond animation requestFrame loop if it's active.
            if (pondAnimationFrameId) {
                cancelAnimationFrame(pondAnimationFrameId);
                pondAnimationFrameId = null; // Reset the animation frame ID.
                console.log("Pond animation frame canceled.");
            }
        }


        // === 4. UI Update Functions ===

        /**
         * Updates the numerical display elements in the "Current State" panel.
         * @param {boolean} randomEvent - True if a random event was applied in the last step.
         */
        function updateDisplay(randomEvent = false) {
            currentGenerationSpan.textContent = generation;
            currentPopulationXSpan.textContent = x.toFixed(4); // Display population with 4 decimal places
            currentGrowthRateSpan.textContent = r.toFixed(2); // Display growth rate with 2 decimal places
            randomEventAppliedSpan.textContent = randomEvent ? 'Yes' : 'No';
            currentPopulationXSpan.style.color = (x <= 0.001) ? '#dc3545' : '#007bff'; // Red if near extinction
            randomEventAppliedSpan.style.color = randomEvent ? '#dc3545' : '#28a745'; // Color coding for random event
        }

        /**
         * Draws the population time series chart.
         * Includes the main population line and an optional moving average line.
         */
        function drawChart() {
            if (!populationChartCtx) {
                console.error("Population Chart Canvas 2D context is not available for drawing. Cannot draw chart.");
                return;
            }
            populationChartCtx.clearRect(0, 0, populationChartCanvas.width, populationChartCanvas.height); // Clear the entire canvas

            // Define graph margins/paddings for consistent layout
            const padding = 50;
            const chartWidth = populationChartCanvas.width - padding;
            const chartHeight = populationChartCanvas.height - padding;

            // Draw X and Y axes
            populationChartCtx.beginPath();
            populationChartCtx.strokeStyle = '#999';
            populationChartCtx.lineWidth = 1;
            populationChartCtx.moveTo(padding, 0); populationChartCtx.lineTo(padding, chartHeight); // Y-axis (Population)
            populationChartCtx.moveTo(padding, chartHeight); populationChartCtx.lineTo(populationChartCanvas.width, chartHeight); // X-axis (Generations)
            populationChartCtx.stroke();

            // Draw Y-axis labels (Population values)
            populationChartCtx.fillStyle = '#555';
            populationChartCtx.font = '12px Arial';
            populationChartCtx.textAlign = 'right';
            populationChartCtx.textBaseline = 'middle';
            populationChartCtx.fillText('1.0', padding - 10, 0 + 10);
            populationChartCtx.fillText('0.5', padding - 10, chartHeight / 2);
            populationChartCtx.fillText('0.0', padding - 10, chartHeight - 5);

            // Draw X-axis label (Generations)
            populationChartCtx.textAlign = 'center';
            populationChartCtx.textBaseline = 'top';
            populationChartCtx.fillText('Generations', padding + chartWidth / 2, chartHeight + 10);

            // Draw the main population line
            populationChartCtx.beginPath();
            populationChartCtx.strokeStyle = '#007bff'; // Blue color
            populationChartCtx.lineWidth = 2;

            // Calculate horizontal step for each data point
            const stepX = chartWidth / (maxDataPoints - 1);

            if (populationHistory.length > 0) {
                populationHistory.forEach((pop, index) => {
                    // Map normalized population (0-1) to canvas Y-coordinate (inverted)
                    const plotX = padding + (index * stepX);
                    const plotY = chartHeight - (pop * chartHeight);

                    if (index === 0) {
                        populationChartCtx.moveTo(plotX, plotY);
                    } else {
                        populationChartCtx.lineTo(plotX, plotY);
                    }
                });
                populationChartCtx.stroke();

                // Draw a red dot for the current (latest) population point
                populationChartCtx.beginPath();
                populationChartCtx.fillStyle = '#dc3545';
                const currentPop = populationHistory[populationHistory.length - 1];
                const currentPlotX = padding + (populationHistory.length - 1) * stepX;
                const currentPlotY = chartHeight - (currentPop * chartHeight);
                populationChartCtx.arc(currentPlotX, currentPlotY, 4, 0, Math.PI * 2);
                populationChartCtx.fill();
            }

            // Draw Moving Average Line if enabled and enough data points exist for the window
            if (movingAverageEnabled && populationHistory.length >= movingAverageWindow) {
                populationChartCtx.beginPath();
                populationChartCtx.strokeStyle = '#000000'; // Black for moving average
                populationChartCtx.lineWidth = 2;
                populationChartCtx.setLineDash([5, 5]); // Dashed line for distinction

                // Iterate from the point where the moving average window is full
                for (let i = movingAverageWindow - 1; i < populationHistory.length; i++) {
                    let sum = 0;
                    // Sum up values within the current window
                    for (let j = 0; j < movingAverageWindow; j++) {
                        sum += populationHistory[i - j];
                    }
                    const average = sum / movingAverageWindow;

                    const plotX = padding + (i * stepX);
                    const plotY = chartHeight - (average * chartHeight);

                    if (i === movingAverageWindow - 1) {
                        populationChartCtx.moveTo(plotX, plotY);
                    } else {
                        populationChartCtx.lineTo(plotX, plotY);
                    }
                }
                populationChartCtx.stroke();
                populationChartCtx.setLineDash([]); // Reset line dash to solid for subsequent drawings
            }
        }

        /**
         * Draws the Phase Space Plot (Return Map).
         * Plots x_n (current population) against x_{n+1} (next population).
         * @param {number} [x_current] - The population value at the current step ($x_n$).
         * @param {number} [x_next] - The population value at the next step ($x_{n+1}$).
         */
        function drawReturnMap(x_current, x_next) {
            if (!returnMapCtx) {
                console.error("Return Map Canvas 2D context is not available for drawing.");
                return;
            }

            const padding = 50;
            const mapWidth = returnMapCanvas.width - padding;
            const mapHeight = returnMapCanvas.height - padding;

            // Clear and redraw axes/reference lines only on initialization (generation 0)
            if (generation === 0) {
                 returnMapCtx.clearRect(0, 0, returnMapCanvas.width, returnMapCanvas.height); // Clear entire canvas
                 // Draw X and Y axes
                 returnMapCtx.beginPath();
                 returnMapCtx.strokeStyle = '#999';
                 returnMapCtx.lineWidth = 1;
                 returnMapCtx.moveTo(padding, 0); returnMapCtx.lineTo(padding, mapHeight); // Y-axis ($x_{n+1}$)
                 returnMapCtx.moveTo(padding, mapHeight); returnMapCtx.lineTo(returnMapCanvas.width, mapHeight); // X-axis ($x_n$)
                 returnMapCtx.stroke();

                 // Axis Labels
                 returnMapCtx.fillStyle = '#555';
                 returnMapCtx.font = '12px Arial';
                 returnMapCtx.textAlign = 'right';
                 returnMapCtx.textBaseline = 'middle';
                 returnMapCtx.fillText('1.0', padding - 10, 0 + 10);
                 returnMapCtx.fillText('0.5', padding - 10, mapHeight / 2);
                 returnMapCtx.fillText('0.0', padding - 10, mapHeight - 5);
                 returnMapCtx.textAlign = 'center';
                 returnMapCtx.textBaseline = 'top';
                 returnMapCtx.fillText('Current Population ($x_n$)', padding + mapWidth / 2, mapHeight + 10);
                 returnMapCtx.save(); // Save context state before rotating for Y-axis label
                 returnMapCtx.translate(padding - 30, mapHeight / 2);
                 returnMapCtx.rotate(-Math.PI / 2);
                 returnMapCtx.fillText('Next Population ($x_{n+1}$)', 0, 0);
                 returnMapCtx.restore(); // Restore context to original state

                 // Draw the y=x diagonal line (stability line)
                 returnMapCtx.beginPath();
                 returnMapCtx.strokeStyle = 'rgba(0, 0, 255, 0.3)'; // Light blue
                 returnMapCtx.lineWidth = 1;
                 returnMapCtx.moveTo(padding, mapHeight); // From (0,0) of graph area
                 returnMapCtx.lineTo(returnMapCanvas.width, 0); // To (1,1) of graph area
                 returnMapCtx.stroke();

                 // Draw the logistic map parabola (the deterministic rule) for reference
                 returnMapCtx.beginPath();
                 returnMapCtx.strokeStyle = 'rgba(128, 0, 128, 0.5)'; // Purple for the curve
                 returnMapCtx.lineWidth = 1;
                 for (let i = 0; i <= 100; i++) {
                     const px = i / 100; // Normalized x_n from 0 to 1
                     const py = r * px * (1 - px); // Corresponding x_{n+1} calculated by logistic map
                     const plotX = padding + px * mapWidth; // Map to canvas X coord
                     const plotY = mapHeight - py * mapHeight; // Map to canvas Y coord (inverted)
                     if (i === 0) {
                         returnMapCtx.moveTo(plotX, plotY);
                     } else {
                         returnMapCtx.lineTo(plotX, plotY);
                     }
                 }
                 returnMapCtx.stroke();
            }

            // Draw the current point (x_current, x_next) if values are provided
            if (generation > 0 && x_current !== undefined && x_next !== undefined) {
                const plotX = padding + x_current * mapWidth;
                const plotY = mapHeight - x_next * mapHeight; // Y-axis inverted for drawing

                returnMapCtx.beginPath();
                returnMapCtx.arc(plotX, plotY, 3, 0, Math.PI * 2); // Draw a small dot
                returnMapCtx.fillStyle = '#007bff'; // Blue dot for current position
                returnMapCtx.fill();
            }
        }

        /**
         * Initializes the Bifurcation Diagram canvas with axes and a placeholder message.
         * This is drawn on initial load or reset.
         */
        function drawBifurcationMapInitialState() {
            if (!bifurcationMapCtx) {
                console.error("Bifurcation Map Canvas 2D context is not available for drawing.");
                return;
            }
            bifurcationMapCtx.clearRect(0, 0, bifurcationMapCanvas.width, bifurcationMapCanvas.height); // Clear entire canvas

            const padding = 50;
            const chartWidth = bifurcationMapCanvas.width - padding;
            const chartHeight = bifurcationMapCanvas.height - padding; // Corrected: Used bifurcationMapCanvas.height

            // Draw X and Y axes
            bifurcationMapCtx.beginPath();
            bifurcationMapCtx.strokeStyle = '#999';
            bifurcationMapCtx.lineWidth = 1;
            bifurcationMapCtx.moveTo(padding, 0); bifurcationMapCtx.lineTo(padding, chartHeight); // Y-axis (Population)
            bifurcationMapCtx.moveTo(padding, chartHeight); bifurcationMapCtx.lineTo(bifurcationMapCanvas.width, chartHeight); // X-axis (Growth Rate 'r')
            bifurcationMapCtx.stroke();

            // Axis Labels
            bifurcationMapCtx.fillStyle = '#555';
            bifurcationMapCtx.font = '12px Arial';
            bifurcationMapCtx.textAlign = 'right';
            bifurcationMapCtx.textBaseline = 'middle';
            bifurcationMapCtx.fillText('1.0', padding - 10, 0 + 10);
            bifurcationMapCtx.fillText('0.5', padding - 10, chartHeight / 2);
            bifurcationMapCtx.fillText('0.0', padding - 10, chartHeight - 5);
            bifurcationMapCtx.textAlign = 'center';
            bifurcationMapCtx.textBaseline = 'top';
            bifurcationMapCtx.fillText('Growth Rate (r)', padding + chartWidth / 2, chartHeight + 10);
            bifurcationMapCtx.save(); // Save context state before rotating for Y-axis label
            bifurcationMapCtx.translate(padding - 30, chartHeight / 2);
            bifurcationMapCtx.rotate(-Math.PI / 2);
            bifurcationMapCtx.fillText('Long-Term Population (x)', 0, 0);
            bifurcationMapCtx.restore(); // Restore context to original state

            // Placeholder message while diagram is not generated
            bifurcationMapCtx.fillStyle = '#666';
            bifurcationMapCtx.textAlign = 'center';
            bifurcationMapCtx.textBaseline = 'middle';
            bifurcationMapCtx.fillText('Click "Generate Bifurcation Diagram" to plot', bifurcationMapCanvas.width / 2, bifurcationMapCanvas.height / 2);
        }

        /**
         * Generates and plots the Bifurcation Diagram for the logistic map.
         * This function can be computationally intensive as it runs many simulations.
         */
        async function generateBifurcationDiagram() {
            if (!bifurcationMapCtx) {
                console.error("Bifurcation Map Canvas 2D context is not available for drawing.");
                return;
            }
            if (generation !== 0) { // Only allow generation from reset state to avoid confusion
                displayMessage("Reset Simulation", "Please reset the simulation first to generate a new Bifurcation Diagram cleanly.");
                return;
            }

            bifurcationMapCtx.clearRect(0, 0, bifurcationMapCanvas.width, bifurcationMapCanvas.height); // Clear existing points
            drawBifurcationMapInitialState(); // Redraw axes/labels

            displayMessage("Generating Bifurcation Diagram", "loading");
            generateBifurcationButton.disabled = true;
            getInsightButton.disabled = true; // Disable other AI button during generation

            const rStart = 0.1;
            const rEnd = 4.0;
            const rSteps = 1000; // Number of r values to test
            const initialTransient = 200; // Number of iterations to discard to let system settle
            const plotIterations = 100; // Number of subsequent iterations to plot

            const padding = 50;
            const chartWidth = bifurcationMapCanvas.width - padding;
            const chartHeight = bifurcationMapCanvas.height - padding;

            bifurcationMapCtx.fillStyle = '#000080'; // Dark blue for dots
            bifurcationMapCtx.globalAlpha = 0.3; // Make points semi-transparent for density

            for (let i = 0; i <= rSteps; i++) {
                const currentR = rStart + (rEnd - rStart) * (i / rSteps);
                let currentX = 0.5; // Start each r value with a fixed initial x

                // Skip transient iterations
                for (let j = 0; j < initialTransient; j++) {
                    currentX = currentR * currentX * (1 - currentX);
                    currentX = Math.max(0, Math.min(1, currentX)); // Keep within bounds
                }

                // Plot the next 'plotIterations' values
                for (let k = 0; k < plotIterations; k++) {
                    currentX = currentR * currentX * (1 - currentX);
                    currentX = Math.max(0, Math.min(1, currentX)); // Keep within bounds

                    const plotX = padding + (currentR - rStart) / (rEnd - rStart) * chartWidth;
                    const plotY = chartHeight - currentX * chartHeight;

                    bifurcationMapCtx.fillRect(plotX, plotY, 1, 1); // Draw a small dot
                }

                await new Promise(resolve => setTimeout(resolve, 0)); // Yield to keep UI responsive
            }

            bifurcationMapCtx.globalAlpha = 1.0; // Reset alpha
            hideMessageBox();
            generateBifurcationButton.disabled = false;
            getInsightButton.disabled = false;
            displayMessage("Bifurcation Diagram Generated!", "The bifurcation diagram has been plotted. Observe how the population's long-term behavior changes with the growth rate (r).");
            console.log("Bifurcation diagram generation complete.");
        }


        // === 5. Pond Animation Functions ===

        /**
         * Initializes the array of fish objects for the pond animation.
         * Fish properties include position, movement vector, color, and size.
         */
        function initializePond() {
            pondFish = []; // Clear any existing fish
            const currentFishCount = Math.floor(x * maxPondFish); // Determine number of fish based on normalized population

            // Ensure canvas dimensions are valid before creating fish positions
            if (pondCanvas && pondCanvas.width > 0 && pondCanvas.height > 0) {
                for (let i = 0; i < currentFishCount; i++) {
                    const size = 3 + Math.random() * 4; // Random size for visual variety
                    pondFish.push({
                        x: Math.random() * pondCanvas.width, // Random X position within pond
                        y: Math.random() * pondCanvas.height, // Random Y position within pond
                        dx: (Math.random() - 0.5) * 1, // Small random horizontal velocity
                        dy: (Math.random() - 0.5) * 1, // Small random vertical velocity
                        color: `hsl(${Math.random() * 30 + 20}, 80%, 60%)`, // Shades of orange/gold
                        size: size
                    });
                }
            }
            console.log(`Pond initialized with ${pondFish.length} fish.`);
        }

        /**
         * The main animation loop for the pond.
         * Updates fish positions, manages fish count, and redraws them.
         */
        function animatePond() {
            // Stop if canvas context is not available or dimensions are zero (e.g., initially hidden)
            if (!pondCtx || pondCanvas.width === 0 || pondCanvas.height === 0) {
                 pondAnimationFrameId = requestAnimationFrame(animatePond); // Keep trying to animate if not ready
                 return;
            }

            // Adjust the number of visual fish to match the current simulated population
            const desiredFishCount = Math.floor(x * maxPondFish);
            while (pondFish.length < desiredFishCount) {
                // Add new fish with random properties if population increases
                const size = 3 + Math.random() * 4;
                pondFish.push({
                    x: Math.random() * pondCanvas.width,
                    y: Math.random() * pondCanvas.height,
                    dx: (Math.random() - 0.5) * 1,
                    dy: (Math.random() - 0.5) * 1,
                    color: `hsl(${Math.random() * 30 + 20}, 80%, 60%)`,
                    size: size
                });
            }
            while (pondFish.length > desiredFishCount) {
                pondFish.pop(); // Remove fish from the end if population decreases
            }

            pondCtx.clearRect(0, 0, pondCanvas.width, pondCanvas.height); // Clear the entire pond canvas for redrawing

            // Update position and redraw each fish
            pondFish.forEach(fish => {
                fish.x += fish.dx;
                fish.y += fish.dy;

                // Simple collision/bounce logic for pond boundaries
                const buffer = fish.size; // Use fish size as a buffer
                if (fish.x < buffer || fish.x > pondCanvas.width - buffer) fish.dx *= -1;
                if (fish.y < buffer || fish.y > pondCanvas.height - buffer) fish.dy *= -1;

                // Introduce slight random changes to direction for more natural movement
                fish.dx += (Math.random() - 0.5) * 0.1;
                fish.dy += (Math.random() - 0.5) * 0.1;
                // Cap speed to prevent fish from moving too fast
                fish.dx = Math.max(-1, Math.min(1, fish.dx));
                fish.dy = Math.max(-1, Math.min(1, fish.dy));

                // Draw each fish as a simple colored circle
                pondCtx.beginPath();
                pondCtx.arc(fish.x, fish.y, fish.size, 0, Math.PI * 2);
                pondCtx.fillStyle = fish.color;
                pondCtx.fill();
                pondCtx.strokeStyle = 'rgba(0,0,0,0.2)'; // Small black border
                pondCtx.lineWidth = 1;
                pondCtx.stroke();
            });

            // Request the next animation frame for a smooth loop
            pondAnimationFrameId = requestAnimationFrame(animatePond);
        }


        // === 6. Utility and LLM Integration Functions ===

        /**
         * Displays a custom message box instead of native alert().
         * Supports a loading state with a spinner.
         * @param {string} title - Title of the message box.
         * @param {string} message - Content of the message. Use 'loading' for spinner.
         */
        function displayMessage(title, message) {
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                // Create message box element if it doesn't exist
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                messageBox.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: #fff; padding: 30px; border-radius: 10px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000; text-align: center;
                    max-width: 400px; width: 90%; animation: fadeIn 0.3s ease-out; display: none;
                `;
                document.body.appendChild(messageBox);

                // Add CSS keyframes for fade animations to document head
                const style = document.createElement('style');
                style.innerHTML = `
                    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -60%); } to { opacity: 1; transform: translate(-50%, -50%); } }
                    @keyframes fadeOut { from { opacity: 1; transform: translate(-50%, -50%); } to { opacity: 0; transform: translate(-50%, -60%); } }
                    .message-box-overlay {
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(0,0,0,0.5); z-index: 999; animation: fadeIn 0.3s ease-out; display: none;
                    }
                `;
                document.head.appendChild(style);
            }

            let overlay = document.getElementById('messageBoxOverlay');
            if (!overlay) {
                // Create overlay element if it doesn't exist
                overlay = document.createElement('div');
                overlay.id = 'messageBoxOverlay';
                overlay.className = 'message-box-overlay';
                document.body.appendChild(overlay);
            }

            const is_loading = message === 'loading';
            const loading_content = is_loading ? '<div class="loading-spinner"></div> Loading...' : '';
            const message_text = is_loading ? '' : message;

            messageBox.innerHTML = `
                <h3 style="color: #007bff; margin-bottom: 15px;">${title}</h3>
                <p style="margin-bottom: 25px;">${message_text} ${loading_content}</p>
                <button id="closeMessageBox" style="background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em; ${is_loading ? 'display:none;' : ''}">OK</button>
            `;
            messageBox.style.display = 'block';
            overlay.style.display = 'block';

            if (!is_loading) {
                // Set up click handler for OK button to close the message box
                document.getElementById('closeMessageBox').onclick = () => {
                    messageBox.style.animation = 'fadeOut 0.3s ease-out forwards';
                    overlay.style.animation = 'fadeOut 0.3s ease-out forwards';
                    setTimeout(() => {
                        messageBox.style.display = 'none';
                        overlay.style.display = 'none';
                    }, 300);
                };
            }
        }

        /**
         * Hides the custom message box and its overlay.
         */
        function hideMessageBox() {
            const messageBox = document.getElementById('messageBox');
            const overlay = document.getElementById('messageBoxOverlay');
            if (messageBox) messageBox.style.display = 'none';
            if (overlay) overlay.style.display = 'none';
        }

        /**
         * Calls the Gemini API to generate text based on a given prompt.
         * Handles loading state and error reporting.
         * @param {string} prompt - The text prompt to send to the LLM.
         * @param {string} outputTitle - The title to display for the LLM output.
         * @returns {Promise<string>} - A promise that resolves with the generated text or an.
         */
        async function callGeminiAPI(prompt, outputTitle) {
            llmOutputArea.style.display = 'block'; // Ensure the LLM output area is visible
            llmOutputTitle.textContent = outputTitle; // Set the title for the LLM output
            llmOutputText.innerHTML = '<div class="loading-spinner"></div> Generating...'; // Show loading spinner within the output area

            // Disable LLM-related buttons during the API call
            getInsightButton.disabled = true;
            generateBifurcationButton.disabled = true; // This button is visible, so disable it

            console.log("Calling Gemini API with prompt:", prompt);

            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = "AIzaSyBe4FaOSzP9GaqTpcvW8lV-wKRu9nH82sA"; // Canvas will provide this API key at runtime

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            let generatedText = "Error: Could not retrieve response.";
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    // If response is not OK (e.g., 4xx, 5xx), parse error details
                    const errorData = await response.json();
                    throw new Error(`API error: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
                }

                const result = await response.json();
                console.log("Gemini API response:", result);

                // Extract generated text from the response structure
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    generatedText = result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Unexpected Gemini API response structure:", result);
                    generatedText = "Could not generate response. Unexpected API structure.";
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                generatedText = `Error generating response: ${error.message}`;
            } finally {
                // Update the LLM output text area with the generated text (or error message)
                llmOutputText.textContent = generatedText;
                // Re-enable LLM-related buttons
                getInsightButton.disabled = false;
                generateBifurcationButton.disabled = false;
            }
        }

        /**
         * Gathers current simulation data and parameters,
         * then constructs a detailed prompt for the LLM to generate insights.
         */
        async function getPopulationInsight() {
            // Determine population behavior description based on 'r' value
            let r_behavior_description = "";
            let chaos_explanation_specific = "";
            let return_map_explanation = "";


            if (r < 3.0) {
                r_behavior_description = "The goldfish population will likely stabilize at a single, predictable size within the pond's carrying capacity.";
                chaos_explanation_specific = "At this 'r' value, the simulation is not in a chaotic regime. The population's behavior is stable and predictable, meaning small differences in starting conditions will not lead to drastically different long-term outcomes. The effects of randomness will be observed as minor, temporary fluctuations around this stable point, but the system will always tend to return to its equilibrium.";
                return_map_explanation = "On the Return Map (Phase Space Plot), you will observe points converging rapidly to a single point where the parabola intersects the $y=x$ diagonal line, indicating a stable equilibrium. Randomness may cause slight scatter around this point, but the underlying attraction to this single equilibrium remains clear. This visual perfectly demonstrates the deterministic stability of the system.";
            } else if (r >= 3.0 && r < 3.449) {
                r_behavior_description = "The goldfish population will oscillate predictably between two or more fixed sizes in a regular cycle (period doubling).";
                chaos_explanation_specific = "The simulation exhibits oscillatory behavior, often seen as period-doubling bifurcations before true chaos. While the population fluctuates, it follows a predictable pattern of values, repeatedly cycling through the same set of sizes. Sensitive dependence is minimal; randomness primarily introduces noise around these predictable cycles, making the oscillations slightly imperfect.";
                return_map_explanation = "On the Return Map, points will jump back and forth between 2 or more distinct points on the parabola, forming a recognizable cycle (e.g., a two-point or four-point attractor). This clearly demonstrates deterministic oscillation. Randomness will appear as slight deviations, causing the plotted points to form small clouds around these exact cycle points rather than being perfectly on them, showing how external factors perturb the underlying cycle.";
            } else if (r >= 3.449 && r < 3.569) {
                r_behavior_description = "The goldfish population will exhibit more complex, multi-period oscillations, on the very edge of chaos.";
                chaos_explanation_specific = "This 'r' value places the simulation in a highly sensitive region, very close to the onset of true chaos. The population's behavior becomes complex, showing multiple oscillating periods (further period-doubling cascade), and is highly susceptible to the 'butterfly effect.' Even tiny, unmeasurable variations, including those from our introduced randomness, can push the system into wildly different, unpredictable paths over time, making long-term prediction increasingly difficult.";
                return_map_explanation = "The Return Map will show points jumping between multiple, more numerous fixed points on the parabola, illustrating the period-doubling cascade in action. The pattern is still discernible but much more intricate, hinting at the upcoming chaos. Randomness makes these complex deterministic patterns less 'clean' and more diffused, reflecting the increasing sensitivity before full chaos takes over.";
            } else { // r >= 3.569
                r_behavior_description = "The goldfish population is in a truly chaotic regime, making long-term prediction practically impossible despite deterministic rules.";
                chaos_explanation_specific = "In this chaotic state, the simulation demonstrates **extreme sensitive dependence on initial conditions, known as the 'butterfly effect.'** This means even if we could precisely know every parameter, a minute, unmeasurable difference (like the smallest fraction of a fish or a microscopic environmental change in the pond) would lead to entirely divergent population trajectories over time. The 'randomness factor' further amplifies this inherent unpredictability, ensuring the observed population behavior never precisely repeats and appears genuinely random in its time series, even though it's fundamentally governed by the simple logistic equation.";
                return_map_explanation = "Despite the seemingly random behavior in the time series chart, the Return Map remains a powerful tool. It will clearly show that *all* generated points still fall precisely on the parabolic curve of the logistic map. This emphatically highlights the deterministic nature of chaos; the system follows an exact rule. However, instead of clustering into fixed points or simple cycles, the points will fill a continuous segment of the parabola, demonstrating the system's unbounded yet structured unpredictability. Randomness will cause these points to scatter slightly *off* the perfect parabolic line, visually indicating how external noise perturbs the underlying deterministic chaotic system. The dense, irregular spread of points across the parabola, rather than converging, is a visual signature of the chaotic 'attractor.'";
            }

            // Determine current population trend
            let x_trend_description = "";
            const lastX = populationHistory[populationHistory.length - 1];
            if (generation > 1 && populationHistory.length > 1) {
                const prevX = populationHistory[populationHistory.length - 2];
                if (lastX > prevX) {
                    x_trend_description = "The goldfish population is currently growing, moving towards a higher number of fish.";
                } else if (lastX < prevX) {
                    x_trend_description = "The goldfish population is currently declining, with fewer fish expected in the next step.";
                } else {
                    x_trend_description = "The goldfish population is currently stable, showing little change from the previous step.";
                }
            } else {
                x_trend_description = "The simulation has just started or reset, and the initial trend is being established.";
            }

            // Describe the effect of randomness
            const randomness_effect = `The 'Randomness Factor' (currently ${randomnessFactor.toFixed(3)}) and 'Randomness Frequency' (currently ${randomnessFrequency.toFixed(2)}) introduce external, unpredictable disturbances to the pond environment. These mimic real-world events, like sudden environmental shifts (e.g., a cold snap, a burst of algae growth) or individual biological events (e.g., a few fish falling sick, an unrecorded predator visit). This randomness further influences the population's path, especially in chaotic regimes where small perturbations have amplified effects, making the system even harder to predict precisely.`;

            // Explanation of fish population
            const fish_population_explanation = `In this simulation, the 'population (x)' represents the goldfish population as a normalized value between 0 and 1. '0' signifies extinction (no fish in the pond), while '1' represents the maximum carrying capacity of the pond (the largest population the environment can sustainably support, given resources). This normalization allows us to focus on the proportional changes and dynamics of the population relative to its environmental limits, simplifying the complexity of tracking exact large numbers of individual fish while still illustrating fundamental ecological principles.`;

            // Detailed explanation of the Bifurcation Diagram
            const bifurcation_diagram_explanation_in_detail = "The Bifurcation Diagram provides a global view of the system's long-term behavior across the entire range of 'r' values. This diagram vividly illustrates the 'road to chaos,' showing how the goldfish population transitions from a single stable size (a single line) to predictable oscillations (period doubling, appearing as branching lines) and then abruptly into dense, unpredictable regions (filled bands) characteristic of chaos. Each point in the diagram represents a possible long-term population value for a given 'r'. This visual is crucial for understanding how qualitatively different behaviors emerge as 'r' changes, highlighting the system's inherent sensitivity and the fundamental principles of chaos theory across its full dynamic range.";

            // Construct the comprehensive prompt for the LLM
            const insightPrompt = `This simulation models goldfish population dynamics using the logistic map (P_next = r * P * (1 - P)) and incorporates random perturbations. It visually demonstrates the **Butterfly Effect** and the principles of chaos theory.

            - **Understanding the Goldfish Population (x):** ${fish_population_explanation}
            - **Population Behavior (based on r=${r.toFixed(2)}):** ${r_behavior_description}
            - **Current Trend:** ${x_trend_description}
            - **Chaos Theory & The Butterfly Effect in the Pond:** This simulation vividly exemplifies how even simple, deterministic rules can lead to profound long-term unpredictability in the goldfish population. For 'r' values in the chaotic range, a minute, unmeasurable difference in the initial goldfish population, or a tiny random event (like a single extra mosquito larva for food or an unexpected mild day), will cause the entire population trajectory to diverge wildly and unpredictably over time. This is the core of the 'butterfly effect' – where small, seemingly insignificant causes lead to large, unforeseen differences in the pond's fish numbers. The system is inherently deterministic, following the logistic map, yet its long-term state is practically unknowable. **The Bifurcation Diagram provides a global view of this phenomenon, visually demonstrating the transitions from stable points to period-doubling oscillations, and eventually to the dense, unpredictable regions characteristic of chaos as the 'r' value increases, showcasing the underlying structure of chaos itself.**
            - **Visualizing Chaos with the Return Map:** The Phase Space Plot (Return Map) is a crucial tool for understanding this. It plots the current population ($x_n$) against the next ($x_{n+1}$). It always shows points on the parabolic curve derived from the logistic map, confirming the deterministic rule. However, in chaotic regimes, instead of settling into fixed points or simple cycles, the points densely fill a section of the parabola, showcasing the 'strange attractor' and the system's bounded yet unpredictable nature. Randomness causes points to scatter slightly *off* this perfect curve, representing external disturbances.
            - **Impact of Randomness:** ${randomness_effect}

            Provide a comprehensive, concise analysis explaining how these elements interact to produce the observed simulation results, focusing on the manifestation of the butterfly effect and the role of both chaos and randomness in the goldfish population. Keep the explanation to about 10-15 sentences.`;

            // Call the Gemini API with the constructed prompt
            callGeminiAPI(insightPrompt, "Population Model & Results Insight:");
        }


        // === 7. Initial Setup and Event Listeners ===

        /**
         * This function is called once the entire window (including all HTML elements) has loaded.
         * It initializes the simulation and sets up global event listeners.
         */
        window.onload = function() {
            // --- Attach Event Listeners ---
            // It is crucial to attach event listeners AFTER the DOM elements are guaranteed to exist,
            // which is why this is done within window.onload.

            // Get all DOM elements inside window.onload to ensure they exist
            growthRateSlider = document.getElementById('growthRate');
            growthRateValueSpan = document.getElementById('growthRateValue');
            initialPopulationSlider = document.getElementById('initialPopulation');
            initialPopulationValueSpan = document.getElementById('initialPopulationValue');
            randomnessFactorSlider = document.getElementById('randomnessFactor');
            randomnessFactorValueSpan = document.getElementById('randomnessFactorValue');
            randomnessFrequencySlider = document.getElementById('randomnessFrequency');
            randomnessFrequencyValueSpan = document.getElementById('randomnessFrequencyValue');

            startButton = document.getElementById('startButton');
            stopButton = document.getElementById('stopButton');
            resetButton = document.getElementById('resetButton');

            getInsightButton = document.getElementById('getInsightButton');
            generateBifurcationButton = document.getElementById('generateBifurcationButton');
            llmOutputArea = document.getElementById('llmOutputArea');
            llmOutputTitle = llmOutputArea.querySelector('h3');
            llmOutputText = document.getElementById('llmOutputText');

            movingAverageEnabledCheckbox = document.getElementById('movingAverageEnabled');
            movingAverageWindowSlider = document.getElementById('movingAverageWindow');
            movingAverageWindowValueSpan = document.getElementById('movingAverageWindowValue');

            currentGenerationSpan = document.getElementById('currentGeneration');
            currentPopulationXSpan = document.getElementById('currentPopulationX');
            currentGrowthRateSpan = document.getElementById('currentGrowthRate');
            randomEventAppliedSpan = document.getElementById('randomEventApplied');

            populationChartCanvas = document.getElementById('populationChart');
            populationChartCtx = populationChartCanvas ? populationChartCanvas.getContext('2d') : null;
            if (!populationChartCanvas) console.error("Error: Population Chart Canvas element not found!");
            if (!populationChartCtx) console.error("Error: 2D context could not be obtained from population chart canvas!");

            pondCanvas = document.getElementById('pondCanvas');
            pondCtx = pondCanvas ? pondCanvas.getContext('2d') : null;
            if (!pondCanvas) console.error("Error: Pond Canvas element not found!");
            if (!pondCtx) console.error("Error: 2D context could not be obtained from pond canvas!");

            returnMapCanvas = document.getElementById('returnMapCanvas');
            returnMapCtx = returnMapCanvas ? returnMapCanvas.getContext('2d') : null;
            if (!returnMapCanvas) console.error("Error: Return Map Canvas element not found!");
            if (!returnMapCtx) console.error("Error: 2D context could not be obtained from return map canvas!");

            bifurcationMapCanvas = document.getElementById('bifurcationMapCanvas');
            bifurcationMapCtx = bifurcationMapCanvas ? bifurcationMapCanvas.getContext('2d') : null;
            if (!bifurcationMapCanvas) console.error("Error: Bifurcation Map Canvas element not found!");
            if (!bifurcationMapCtx) console.error("Error: 2D context could not be obtained from bifurcation map canvas!");


            if (startButton) {
                startButton.addEventListener('click', () => {
                    console.log("Start button clicked. Attempting to start simulation.");
                    startSimulation();
                });
                console.log("Start button event listener attached.");
            } else {
                console.error("Start button element not found!");
            }

            if (stopButton) {
                stopButton.addEventListener('click', () => {
                    console.log("Stop button clicked. Attempting to stop simulation.");
                    stopSimulation();
                });
                console.log("Stop button event listener attached.");
            } else {
                console.error("Stop button element not found!");
            }

            if (resetButton) {
                resetButton.addEventListener('click', () => {
                    console.log("Reset button clicked. Stopping and re-initializing simulation.");
                    stopSimulation();
                    initializeSimulation();
                });
                console.log("Reset button event listener attached.");
            } else {
                console.error("Reset button element not found!");
            }

            if (getInsightButton) {
                getInsightButton.addEventListener('click', getPopulationInsight);
                console.log("Get Insight button event listener attached.");
            } else {
                console.error("Get Insight button element not found!");
            }

            if (generateBifurcationButton) {
                generateBifurcationButton.addEventListener('click', generateBifurcationDiagram);
                console.log("Generate Bifurcation button event listener attached.");
            } else {
                console.error("Generate Bifurcation button element not found!");
            }

            // Slider event listeners
            growthRateSlider.addEventListener('input', () => {
                growthRateValueSpan.textContent = growthRateSlider.value;
                r = parseFloat(growthRateSlider.value);
                if (!simulationInterval) {
                    currentGrowthRateSpan.textContent = r.toFixed(2);
                }
                drawReturnMap(); // Update parabola visually if not simulating
                console.log(`Growth rate slider adjusted: ${r}`);
            });

            initialPopulationSlider.addEventListener('input', () => {
                initialPopulationValueSpan.textContent = initialPopulationSlider.value;
                if (!simulationInterval) {
                    x = parseFloat(initialPopulationSlider.value);
                    currentPopulationXSpan.textContent = x.toFixed(4);
                    populationHistory[0] = x;
                    drawChart();
                    initializePond(); // Re-initialize pond on initial population change
                    drawReturnMap(); // Redraw return map
                }
                console.log(`Initial population slider adjusted: ${x}`);
            });

            randomnessFactorSlider.addEventListener('input', () => {
                randomnessFactorValueSpan.textContent = randomnessFactorSlider.value;
                randomnessFactor = parseFloat(randomnessFactorSlider.value);
                console.log(`Randomness factor slider adjusted: ${randomnessFactor}`);
            });

            randomnessFrequencySlider.addEventListener('input', () => {
                randomnessFrequencyValueSpan.textContent = randomnessFrequencySlider.value;
                randomnessFrequency = parseFloat(randomnessFrequencySlider.value);
                console.log(`Randomness frequency slider adjusted: ${randomnessFrequency}`);
            });

            movingAverageEnabledCheckbox.addEventListener('change', () => {
                movingAverageEnabled = movingAverageEnabledCheckbox.checked;
                drawChart();
                console.log(`Moving Average Enabled: ${movingAverageEnabled}`);
            });

            movingAverageWindowSlider.addEventListener('input', () => {
                movingAverageWindow = parseInt(movingAverageWindowSlider.value);
                movingAverageWindowValueSpan.textContent = movingAverageWindowSlider.value;
                drawChart();
                console.log(`Moving Average Window: ${movingAverageWindow}`);
            });


            // Perform initial simulation setup on page load.
            initializeSimulation();
            console.log("Script loaded and initial simulation state set. Ready to start.");

            // Add a resize listener for all canvases to ensure responsiveness.
            window.addEventListener('resize', () => {
                // Adjust all canvas dimensions, maintaining aspect ratio for charts.
                if (pondCanvas) {
                    const container = pondCanvas.parentElement;
                    pondCanvas.width = container.clientWidth;
                    pondCanvas.height = container.clientHeight;
                }
                if (populationChartCanvas) {
                    const container = populationChartCanvas.parentElement;
                    populationChartCanvas.width = container.clientWidth;
                    populationChartCanvas.height = container.clientWidth * (400/800);
                }
                if (returnMapCanvas) {
                    const container = returnMapCanvas.parentElement;
                    returnMapCanvas.width = container.clientWidth;
                    returnMapCanvas.height = container.clientWidth * (400/800);
                }
                if (bifurcationMapCanvas) {
                    const container = bifurcationMapCanvas.parentElement;
                    bifurcationMapCanvas.width = container.clientWidth;
                    bifurcationMapCanvas.height = container.clientWidth * (400/800);
                    drawBifurcationMapInitialState(); // Redraw labels for resizing
                }

                drawChart(); // Redraw charts on resize
                initializePond(); // Re-initialize pond to distribute fish correctly on resize
                drawReturnMap(); // Redraw return map (clears old points and draws axes/parabola)
            });
        };
    </script>
</body>
</html>
